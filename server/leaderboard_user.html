<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BubbleClash — Leaderboard (User)</title>
  <style>
    :root{--bg1:#071029;--bg2:#0f172a;--card:#0b1220;--accent:#7c3aed}
    html,body{height:100%;margin:0}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(120deg,var(--bg1),var(--bg2));color:#fff;padding:28px;}
    .wrap{max-width:1200px;margin:0 auto}
    h1{font-size:24px;margin:0 0 18px 0;letter-spacing:0.4px}

    /* animated gradient background glow */
    .hero{position:relative;padding:18px;border-radius:16px;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.6);}
    .glow{position:absolute;left:-20%;top:-30%;width:160%;height:160%;background:radial-gradient(circle at 20% 20%, rgba(124,58,237,0.12), transparent 10%, transparent 50%), radial-gradient(circle at 80% 80%, rgba(14,165,233,0.06), transparent 8%);filter:blur(40px);animation:glow 8s linear infinite;pointer-events:none}
    @keyframes glow{0%{transform:translateY(0)}50%{transform:translateY(10px)}100%{transform:translateY(0)}}

    .controls{display:flex;gap:8px;align-items:center;z-index:2;position:relative}
    select,input{background:rgba(255,255,255,0.03);border:0;padding:10px;border-radius:8px;color:#fff}
    button{background:linear-gradient(90deg,var(--accent),#0ea5e9);border:0;padding:8px 12px;border-radius:10px;color:#fff;cursor:pointer}

    .card{margin-top:16px;border-radius:12px;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(2,6,23,0.6);z-index:2}
    .statBar{height:8px;background:linear-gradient(90deg,#7c3aed,#0ea5e9);border-radius:999px;width:0;transition:width 900ms cubic-bezier(.2,.9,.2,1);box-shadow:0 4px 10px rgba(0,0,0,0.35)}
    .detailPanel{display:flex;gap:20px;align-items:center;padding:18px;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 18px 60px rgba(2,6,23,0.55);animation:panelIn 320ms ease-out}
    .detailAvatar{width:220px;height:220px;border-radius:16px;background:linear-gradient(135deg,#7c3aed,#0ea5e9);display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:800;color:#fff;box-shadow:0 18px 60px rgba(0,0,0,0.55);overflow:hidden;transform:translateZ(30px)}
    .detailAvatar.pulse{animation:avatarPulse 1400ms ease-in-out infinite}
    .detailAvatar img{width:100%;height:100%;object-fit:cover;display:block}
    @keyframes avatarPulse{0%{transform:scale(1)}50%{transform:scale(1.04)}100%{transform:scale(1)}}
    .detailStats{flex:1}
    .detailStats h2{margin:0 0 8px 0;font-size:22px}
    .detailRow{display:flex;align-items:center;gap:12px;margin:8px 0}
    .detailLabel{width:88px;color:rgba(255,255,255,0.75)}
    .statValue{font-weight:800;min-width:48px;text-align:right}
    .backBtn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;margin-bottom:10px;position:relative;z-index:30}
    .detailFull{display:flex;flex-direction:column;gap:12px}
    @keyframes panelIn{from{opacity:0;transform:translateY(8px) scale(.99)}to{opacity:1;transform:none}}
    .row{display:grid;grid-template-columns:48px 1fr 90px 90px 80px 100px;gap:8px;padding:12px 16px;align-items:center}
    .row.header{font-weight:700;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));}
    .player{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    /* 3D tilt effect on hover */
    .tilt-area{perspective:1200px}
    .tilt-card{transition:transform 0.15s ease-out;transform-style:preserve-3d}

    .muted{color:rgba(255,255,255,0.6);font-size:13px}

    /* responsive adjustments */
    @media (max-width:640px){.row{grid-template-columns:32px 1fr 60px 60px 60px;padding:8px}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Leaderboard — User View</h1>
    <div class="hero tilt-area" id="hero">
      <div class="glow" aria-hidden></div>
      <div style="position:relative;z-index:2;padding:12px">
        <div class="controls">
          <label for="gameSelect" class="muted">View:</label>
          <label for="modeSelect" class="muted">Mode:</label>
          <select id="modeSelect"><option value="normal">Normal Arena</option><option value="boss">Boss Arena</option></select>
          <select id="gameSelect"></select>
          <input id="search" placeholder="Search player..." />
          <button id="refresh">Refresh</button>
        </div>
      </div>

      <!-- LIST VIEW: controls, top player, and table -->
      <div id="listView">
        <!-- TOP PLAYER CARD -->
        <div id="topPlayer" style="margin-top:12px;">
          <!-- filled dynamically -->
        </div>

        <div class="card tilt-card" id="table">
        <div class="row header">
          <div style="width:48px">#</div>
          <div>Player</div>
          <div style="text-align:right">Kills</div>
          <div style="text-align:right">Hits</div>
          <div style="text-align:right">Wins</div>
          <div style="text-align:right">Points</div>
        </div>
        <div id="rows"></div>
        </div>
      </div>

      <!-- DETAIL PANEL (shows when clicking a row) - full focus view -->
      <div id="detailPanelWrap" style="margin-top:12px;">
        <button id="persistentBack" class="backBtn" style="display:none;margin-bottom:8px">← Back to leaderboard</button>
        <div id="detailPanel" style="display:none;">
          <!-- filled dynamically -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // The user view intentionally mirrors the admin logic but omits admin controls (reset etc.)
    const rowsEl = document.getElementById('rows');
    const refreshBtn = document.getElementById('refresh');
    const gameSelect = document.getElementById('gameSelect');
    const searchInput = document.getElementById('search');
    const modeSelect = document.getElementById('modeSelect');

    let gamesCache = [];
    let currentList = [];
      function isBossGame(game){
        if(!game) return false;
        // if server-provided metadata includes winner or id containing boss hints
        try{
          const w = String(game.winner||'').toLowerCase();
          const id = String(game.id||'').toLowerCase();
          if(w && (w.includes('boss') || w.includes('super') || w.includes('superbubble') || w.includes('bossimg'))) return true;
          if(id && (id.includes('boss') || id.includes('super') || id.includes('superbubble'))) return true;
        }catch(e){}
        // if full players map present, fall back to player-key heuristic
        if(game.players){
          const keys = Object.keys(game.players||{}).map(k=>String(k).toLowerCase());
          return keys.some(k=> k.includes('boss') || k.includes('super') || k.includes('superbubble') || k.includes('bossimg'));
        }
        return false;
      }
      function shortKey(k){ return String(k||'').replace(/^https?:\/\/[^\/]+\//,'').replace(/^\/+/, '').split('/').pop().toLowerCase(); }

    function showTopPlayer(p){
      const wrap = document.getElementById('topPlayer');
      if(!p){ wrap.innerHTML = ''; return; }
      const raw = String(p.player||'');
      const name = raw.replace(/^https?:\/\/[^\/]+\//,'').replace(/^\/+/, '').split('/').pop()||raw;
      const kills = p.kills||0; const hits = p.hits||0; const wins = p.wins||0;
      const points = (kills*5) + (hits*3) + (wins*10);
      const maxAll = Math.max(1, kills, hits, wins, points);
      wrap.innerHTML = `
        <div class="card" style="display:flex;gap:12px;align-items:center;padding:12px;">
          <div style="width:84px;height:84px;border-radius:50%;background:linear-gradient(135deg,#7c3aed,#0ea5e9);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:26px;color:#fff;box-shadow:0 8px 30px rgba(0,0,0,0.45);transform:translateZ(20px);">
            ${(name||'P').slice(0,2).toUpperCase()}
          </div>
          <div style="flex:1;"> 
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px"><div style="font-weight:800">${name}</div><div class="muted">Top Player</div></div>
            <div style="display:flex;gap:10px;align-items:center">
              <div style="flex:1">
                <div class="muted" style="font-size:12px">Kills</div>
                <div class="statBar" data-val="${kills}" style="--pct:${Math.round((kills/maxAll)*100)}%"></div>
              </div>
              <div style="flex:1">
                <div class="muted" style="font-size:12px">Hits</div>
                <div class="statBar" data-val="${hits}" style="--pct:${Math.round((hits/maxAll)*100)}%"></div>
              </div>
              <div style="flex:0 0 90px;text-align:right">
                <div class="muted" style="font-size:12px">Wins</div>
                <div style="font-weight:700">${wins}</div>
              </div>
              <div style="flex:0 0 100px;text-align:right">
                <div class="muted" style="font-size:12px">Points</div>
                <div style="font-weight:700">${points}</div>
              </div>
            </div>
          </div>
        </div>
      `;
      // trigger CSS animation by forcing layout then setting width via inline style
      requestAnimationFrame(()=>{
        const bars = wrap.querySelectorAll('.statBar');
        bars.forEach(b=>{ const pct = b.getAttribute('style')?.match(/--pct:(\d+)%/)?.[1]||'0'; b.style.width = pct + '%'; });
      });
    }

    // Normal arena rows (players)
    function showRows(data){
      // ensure header visible for normal mode
      const hdr = document.querySelector('.row.header'); if(hdr) hdr.style.display = 'grid';
      const q = (searchInput.value || '').toLowerCase().trim();
      const filtered = data.filter(r => !q || (String(r.player||'').toLowerCase().includes(q)));
      if (!filtered || filtered.length === 0) {
        rowsEl.innerHTML = '<div class="row"><div class="muted" style="grid-column:1/-1;padding:12px">No data yet.</div></div>';
        return;
      }
      // compute points for each entry and sort by points desc
      filtered.forEach(r=>{ r._points = ((r.kills||0)*5 + (r.hits||0)*3 + (r.wins||0)*10); });
      filtered.sort((a,b)=>b._points - a._points || (b.kills||0)-(a.kills||0));

      rowsEl.innerHTML = filtered.map((r,i)=>{
        const raw = String(r.player||'');
        const player = raw.replace(/^https?:\/\/[^\/]+\//,'').replace(/^\/+/, '').split('/').pop()||raw;
        const kills = r.kills||0; const hits = r.hits||0; const wins = r.wins||0;
        const points = r._points || ((kills*5)+(hits*3)+(wins*10));
        return `<div class="row player-row" data-idx="${i}" style="cursor:pointer"><div style="width:48px">${i+1}</div><div class="player" title="${r.player}">${player}</div><div style="text-align:right">${kills}</div><div style="text-align:right">${hits}</div><div style="text-align:right">${wins}</div><div style="text-align:right">${points}</div></div>`;
      }).join('');
      // attach click handlers to rows to open detail panel
      const rowEls = rowsEl.querySelectorAll('.player-row');
      rowEls.forEach((el)=>{
        // remove previously attached handler if any
        if(el._lbClick) el.removeEventListener('click', el._lbClick);
        const handler = ()=>{
          const idx = Number(el.getAttribute('data-idx'))||0;
          const playerObj = filtered[idx];
          showDetailPanel(playerObj);
        };
        el._lbClick = handler;
        el.addEventListener('click', handler);
      });
    }

    // Boss arena: show list of games (one row per game)
    function showBossGameList(games){
      // hide top player card in boss mode
      const tp = document.getElementById('topPlayer'); if(tp) tp.innerHTML = '';
      // filter only boss games
      const bossGames = (games||[]).filter(isBossGame);
      if(!bossGames || bossGames.length===0){
        rowsEl.innerHTML = '<div class="row"><div class="muted" style="grid-column:1/-1;padding:12px">No boss games yet.</div></div>';
        return;
      }
      // hide header for boss mode
      const hdr = document.querySelector('.row.header'); if(hdr) hdr.style.display = 'none';
      // show simple rows: index + label (Game 1, Game 2...)
      rowsEl.innerHTML = bossGames.map((g,i)=>{
        const dt = g.createdAt?new Date(g.createdAt).toLocaleString():g.id;
        const label = `Game ${i+1} — ${dt}` + (g.winner?` — Winner: ${String(g.winner).split('/').pop()}`:'');
        return `<div class="row boss-row" data-game="${g.id}" style="cursor:pointer"><div style="width:48px">${i+1}</div><div class="player" style="grid-column:2 / -1">${label}</div></div>`;
      }).join('');
      // attach handlers: load per-game entries from server (boss store) when clicked
      const els = rowsEl.querySelectorAll('.boss-row');
      els.forEach(el=>{ el.addEventListener('click', ()=>{ const gid = el.getAttribute('data-game'); const meta = bossGames.find(x=>x.id===gid); if(gid) loadBossGameDetail(gid, meta); }); });
    }

    // Show boss game detail: left = boss image + stats (hits,kills,wins,points), right = list of normal images (hits only)
    async function loadBossGameDetail(gameId, meta){
      try{
        const url = `/api/stats?game=${encodeURIComponent(gameId)}&arena=boss`;
        const res = await fetch(url);
        if(!res.ok) throw new Error('failed');
        const entries = await res.json();
        // convert entries array to map-style object expected by renderer
        const playersMap = {};
        entries.forEach(e=>{ playersMap[e.player] = { hits: e.hits||0, kills: e.kills||0, wins: e.wins||0 }; });
        const gameObj = Object.assign({}, meta || {}, { id: gameId, players: playersMap, winner: (meta && meta.winner) || null });
        renderBossGameDetail(gameObj);
      }catch(e){
        console.error('Failed to load boss game detail', e);
        rowsEl.innerHTML = '<div class="row"><div class="muted" style="grid-column:1/-1;padding:12px">Failed to load game details</div></div>';
      }
    }

    function renderBossGameDetail(gameObj){
      const panel = document.getElementById('detailPanel');
      const listView = document.getElementById('listView');
      if(listView) listView.style.display = 'none';
      panel.style.display = 'block';
      const persistentBackBtn = document.getElementById('persistentBack');
      if(persistentBackBtn) persistentBackBtn.style.display = 'inline-block';

      // identify boss image: prefer explicit winner, else pick player with highest (kills+hits)
      const players = gameObj.players || {};
      let bossKey = gameObj.winner || Object.keys(players)[0];
      if(!bossKey){ panel.innerHTML = '<div class="muted">No data</div>'; return; }
      if(!gameObj.winner){
        // choose max
        bossKey = Object.keys(players).reduce((a,b)=>{ const sa=(players[a].kills||0)+(players[a].hits||0); const sb=(players[b].kills||0)+(players[b].hits||0); return sa>=sb? a:b; });
      }

      const boss = players[bossKey] || {hits:0,kills:0,wins:0};
      const bossName = bossKey.replace(/^https?:\/\/[^\/]+\//,'').split('/').pop();
      const bossPoints = (boss.kills||0)*5 + (boss.hits||0)*3 + (boss.wins||0)*10;

      // build right side normal players list (exclude boss)
      const normalKeys = Object.keys(players).filter(k=>k!==bossKey).map(k=>({ key:k, hits: players[k].hits||0 }));

      panel.innerHTML = `
        <div class="detailFull" style="display:flex;gap:18px;align-items:flex-start">
          <div style="flex:0 0 360px">
            <div class="detailAvatar pulse" style="width:320px;height:320px;border-radius:12px;overflow:hidden">
              <img src="/bossimgs/${encodeURIComponent(bossName)}" onerror="this.onerror=null;this.src='/images/${encodeURIComponent(bossName)}'" style="width:100%;height:100%;object-fit:cover" />
            </div>
            <div style="margin-top:10px">
              <div style="font-weight:800">${bossName}</div>
              <div class="muted">Boss — Hits: ${boss.hits||0} • Kills: ${boss.kills||0} • Wins: ${boss.wins||0}</div>
              <div style="margin-top:6px;font-weight:700">Points: ${bossPoints}</div>
            </div>
          </div>
          <div style="flex:0 0 80px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:28px;color:rgba(255,255,255,0.85)">VS</div>
          <div style="flex:1">
            <h3 style="margin:0 0 8px 0">Normal Images</h3>
            <div class="card" style="padding:8px;display:grid;grid-template-columns:72px 1fr 88px;gap:8px;align-items:center">
              ${normalKeys.length===0?'<div class="muted" style="grid-column:1/-1;padding:8px">No normal images</div>':normalKeys.map(n=>{
                const nName = n.key.replace(/^https?:\/\/[^\/]+\//,'').split('/').pop();
                const isWinner = shortKey(gameObj.winner||'') === shortKey(n.key||'');
                const imgStyle = isWinner ? 'width:64px;height:64px;object-fit:cover;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.5)' : 'width:64px;height:64px;object-fit:cover;border-radius:8px;filter:grayscale(100%);opacity:0.6';
                return `<div style="display:flex;align-items:center;gap:8px"><img src="/images/${encodeURIComponent(nName)}" onerror="this.onerror=null;this.src='/bossimgs/${encodeURIComponent(nName)}'" style="${imgStyle}" /></div><div style="overflow:hidden;white-space:nowrap;text-overflow:ellipsis">${nName}</div><div style="text-align:right" class="muted">Hits: ${n.hits}</div>`;
              }).join('')}
            </div>
          </div>
        </div>
      `;
    }

    async function fetchGames(mode='normal'){
      try{
        const arenaQ = mode === 'boss' ? '?arena=boss' : '?arena=normal';
        const res = await fetch('/api/stats/games' + arenaQ);
        const data = await res.json();
        gamesCache = data||[];
        populateSelect(mode);
      }catch(e){console.error(e)}
    }

      function populateSelect(mode='normal'){
        const sel = document.getElementById('gameSelect');
        if(!gamesCache) return;
        // gamesCache is loaded per-mode by fetchGames(mode) so just use it directly
        const list = gamesCache.slice();
        sel.innerHTML = '<option value="combined">All</option>' + list.map(g=>{
          const dt = g.createdAt?new Date(g.createdAt).toLocaleString():g.id;
          return `<option value="${g.id}">${g.id} — ${dt}</option>`;
        }).join('');
      }

    async function fetchStatsFor(selection){
      try{
        // Mode-aware fetching
        const mode = (modeSelect && modeSelect.value) || 'normal';
        if(mode === 'boss'){
          // ensure gamesCache is fresh and render boss game list
          await fetchGames('boss');
          showBossGameList(gamesCache);
          return;
        }
        // normal mode
        let url = '/api/stats';
        if(selection && selection!=='combined') url = `/api/stats?game=${encodeURIComponent(selection)}`;
        const res = await fetch(url);
        if(!res.ok) throw new Error('network');
        const data = await res.json();
        // compute points per player and sort by points desc
        const list = (data||[]).map(r=>({ ...r, _points: ((r.kills||0)*5 + (r.hits||0)*3 + (r.wins||0)*10) }));
        list.sort((a,b)=>b._points - a._points || (b.kills||0)-(a.kills||0));
        currentList = list;
        showRows(currentList);
      }catch(e){
        console.error(e);
        rowsEl.innerHTML = '<div class="row"><div class="muted" style="grid-column:1/-1;padding:12px">Failed to load leaderboard</div></div>';
      }
    }
    
    // extend fetchStatsFor to update top player card when data loaded (only in normal mode)
    const _origFetch = fetchStatsFor;
    fetchStatsFor = async function(selection){
      await _origFetch(selection);
      const mode = (modeSelect && modeSelect.value) || 'normal';
      if(mode === 'normal') showTopPlayer(currentList && currentList.length>0 ? currentList[0] : null);
    };

    function showDetailPanel(p){
      const panel = document.getElementById('detailPanel');
      const listView = document.getElementById('listView');
      if(!p){ hideDetailPanel(); return; }
      // hide the list view to focus only on detail
      if(listView) listView.style.display = 'none';
      panel.style.display = 'block';
      // show persistent back button if available
      const persistentBackBtn = document.getElementById('persistentBack');
      if(persistentBackBtn) persistentBackBtn.style.display = 'inline-block';
      panel.innerHTML = '';
      const raw = String(p.player||'');
      const name = raw.replace(/^https?:\/\/[^\/]+\//,'').replace(/^\/+/, '').split('/').pop()||raw;
      const kills = p.kills||0, hits = p.hits||0, wins = p.wins||0;
      const points = (kills*5) + (hits*3) + (wins*10);
      const maxAll = Math.max(1, kills, hits, wins, points);
      const imgSrcCandidates = [`/images/${encodeURIComponent(name)}` , `/bossimgs/${encodeURIComponent(name)}`, `/superbubbleimg/${encodeURIComponent(name)}`];
      const imgTag = `<img id="detailImg" src="${imgSrcCandidates[0]}" alt="${name}" style="width:100%;height:100%;object-fit:cover" onerror="this.onerror=null;this.src='data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'400\' height=\'400\'><rect width=\'100%\' height=\'100%\' fill=\'%237c3aed\'/><text x=\'50%\' y=\'50%\' dominant-baseline=\'middle\' text-anchor=\'middle\' font-size=\'80\' fill=\'white\'>${encodeURIComponent(name.slice(0,2).toUpperCase())}</text></svg>'">`;
      panel.innerHTML = `
        <div class="detailFull">
          <div class="detailPanel" role="dialog" aria-label="Player details">
            <div class="detailAvatar pulse">${imgTag}</div>
            <div class="detailStats">
              <h2>${name}</h2>
              <div class="detailRow"><div class="detailLabel">Kills</div><div style="flex:1"><div class="statBar" data-val="${kills}" style="--pct:${Math.round((kills/maxAll)*100)}%"></div></div><div class="statValue" id="valKills">0</div></div>
              <div class="detailRow"><div class="detailLabel">Hits</div><div style="flex:1"><div class="statBar" data-val="${hits}" style="--pct:${Math.round((hits/maxAll)*100)}%"></div></div><div class="statValue" id="valHits">0</div></div>
              <div class="detailRow"><div class="detailLabel">Wins</div><div style="flex:1"><div class="statBar" data-val="${wins}" style="--pct:${Math.round((wins/maxAll)*100)}%"></div></div><div class="statValue" id="valWins">0</div></div>
              <div class="detailRow"><div class="detailLabel">Points</div><div style="flex:1"><div class="statBar" data-val="${points}" style="--pct:${Math.round((points/maxAll)*100)}%"></div></div><div class="statValue" id="valPoints">0</div></div>
            </div>
          </div>
        </div>
      `;
      // animate bars and count up numbers
      requestAnimationFrame(()=>{
        const bars = panel.querySelectorAll('.statBar');
        bars.forEach(b=>{ const pct = b.getAttribute('style')?.match(/--pct:(\d+)%/)?.[1]||'0'; b.style.width = pct + '%'; });
        animateCount(panel.querySelector('#valKills'), kills, 800);
        animateCount(panel.querySelector('#valHits'), hits, 800);
        animateCount(panel.querySelector('#valWins'), wins, 800);
        animateCount(panel.querySelector('#valPoints'), points, 900);
      });
      // persistent back button is used instead of injecting a per-panel button
      // allow ESC to go back — keep a reference on window so we can remove it cleanly
      if(window._leaderboardEscHandler) document.removeEventListener('keydown', window._leaderboardEscHandler);
      window._leaderboardEscHandler = (e)=>{ if(e.key === 'Escape') hideDetailPanel(); };
      document.addEventListener('keydown', window._leaderboardEscHandler);
    }

    function hideDetailPanel(){
      const panel = document.getElementById('detailPanel');
      const listView = document.getElementById('listView');
      if(panel) { panel.style.display='none'; panel.innerHTML=''; }
      if(listView) listView.style.display='block';
      const persistentBackBtn = document.getElementById('persistentBack');
      if(persistentBackBtn) persistentBackBtn.style.display = 'none';
      // remove ESC handler if present
      if(window._leaderboardEscHandler){ document.removeEventListener('keydown', window._leaderboardEscHandler); window._leaderboardEscHandler = null; }
      // re-render rows to ensure click handlers are active (mode-aware)
      const mode = (modeSelect && modeSelect.value) || 'normal';
      if(mode === 'boss'){
        showBossGameList(gamesCache);
      } else {
        showRows(currentList);
      }
    }

    function animateCount(el, target, duration){
      if(!el) return; const start = 0; const end = Number(target)||0; const startTime = performance.now();
      const step = (now)=>{ const t = Math.min(1, (now - startTime)/duration); const eased = t<.5?2*t*t: -1 + (4-2*t)*t; const val = Math.round(start + (end - start)*eased); el.textContent = val; if(t < 1) requestAnimationFrame(step); };
      requestAnimationFrame(step);
    }

    refreshBtn.addEventListener('click', ()=>{ const mode = (modeSelect && modeSelect.value) || 'normal'; fetchGames(mode); fetchStatsFor(gameSelect.value||'combined'); });
    gameSelect.addEventListener('change', ()=>fetchStatsFor(gameSelect.value||'combined'));
    searchInput.addEventListener('input', ()=>{
      const mode = (modeSelect && modeSelect.value) || 'normal';
      if(mode === 'normal') showRows(currentList);
    });
    if(modeSelect){ modeSelect.addEventListener('change', ()=>{ if(modeSelect.value==='boss'){ fetchGames('boss').then(()=>fetchStatsFor('combined')); } else { fetchGames('normal').then(()=>fetchStatsFor(gameSelect.value||'combined')); } }); }

    (async()=>{ const mode = (modeSelect && modeSelect.value) || 'normal'; await fetchGames(mode); fetchStatsFor(gameSelect.value||'combined'); })();

    // 3D tilt effect (subtle) for the hero card
    (function(){
      const hero = document.getElementById('hero');
      const card = document.querySelector('.tilt-card');
      if(!hero||!card) return;
      hero.addEventListener('pointermove', (e)=>{
        const rect = hero.getBoundingClientRect();
        const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2;
        const dx = e.clientX - cx; const dy = e.clientY - cy; const rx = -(dy/rect.height)*6; const ry = (dx/rect.width)*8;
        card.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) translateZ(10px)`;
      });
      hero.addEventListener('pointerleave', ()=>{ card.style.transform='none'; });
    })();

    // Persistent back button handler and delegated handler for dynamic back buttons
    const persistentBack = document.getElementById('persistentBack');
    if(persistentBack) persistentBack.addEventListener('click', hideDetailPanel);
    document.addEventListener('click', (e)=>{
      const back = e.target.closest && e.target.closest('.backBtn');
      if(back) {
        hideDetailPanel();
      }
    });
  </script>
</body>
</html>
